"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.decodeAudioData = decodeAudioData;
exports.decodePCMInBase64 = decodePCMInBase64;
var _AudioBuffer = _interopRequireDefault(require("./AudioBuffer"));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
class AudioDecoder {
  static instance = null;
  constructor() {
    this.decoder = global.createAudioDecoder();
  }
  static getInstance() {
    if (!AudioDecoder.instance) {
      AudioDecoder.instance = new AudioDecoder();
    }
    return AudioDecoder.instance;
  }
  async decodeAudioDataInstance(input, sampleRate) {
    let buffer;
    if (typeof input === 'string') {
      // Remove the file:// prefix if it exists
      if (input.startsWith('file://')) {
        input = input.replace('file://', '');
      }
      buffer = await this.decoder.decodeWithFilePath(input, sampleRate ?? 0);
    } else if (input instanceof ArrayBuffer) {
      buffer = await this.decoder.decodeWithMemoryBlock(new Uint8Array(input), sampleRate ?? 0);
    }
    if (!buffer) {
      throw new Error('Unsupported input type or failed to decode audio');
    }
    return new _AudioBuffer.default(buffer);
  }
  async decodePCMInBase64Instance(base64String, inputSampleRate, inputChannelCount, interleaved) {
    const buffer = await this.decoder.decodeWithPCMInBase64(base64String, inputSampleRate, inputChannelCount, interleaved);
    return new _AudioBuffer.default(buffer);
  }
}
async function decodeAudioData(input, sampleRate) {
  return AudioDecoder.getInstance().decodeAudioDataInstance(input, sampleRate);
}
async function decodePCMInBase64(base64String, inputSampleRate, inputChannelCount, isInterleaved = true) {
  return AudioDecoder.getInstance().decodePCMInBase64Instance(base64String, inputSampleRate, inputChannelCount, isInterleaved);
}
//# sourceMappingURL=AudioDecoder.js.map